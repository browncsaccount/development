# Development

### Link to Deployed Website
If you used the stencil code, this is `https://browncsaccount.github.io/development`

### Goal and Value of the Application
This application works as an interactive interface for the Cave, a vinyl store for a myriad of albums. Users are able to filter the store's catalog by genre or decade as well as sort the catalog by price, album name, and artist name. Additionally, users can add or remove any product from the Cave in their personalized list of Favorites. If the users chooses to purchase their favorites, they can see the total price of all their favorited items.

### Usability Principles Considered
While designing the interface, I considered the usability principle of consistency. All the features that users can edit, such as the buttons and filters, have a similar look which makes it easier for users to know which parts they can edit. Furthermore, I considered integrating flexibility and efficiency of use in my design; users should be able to get what they want out of the interface as easily and quickly as possible. For this reason, I ensured that users are able to stack the filters so that they can shop by genre or decade as well as sort this by price or album title. These features allow for the user to find what they need in the best possible way. Furthermore, I made my site keeping in mind that it should be aesthetic and minimal. I cut out any unnecessary or irrelevant information on the site so that it does not distract the user. Furthermore, I kept all the user dependent selection features (like the filters, sorting option, and favorites) on the side bar so that the user has quick access to it.  

### Organization of Components
I have a few different function components to develop a clean architecture. In App, the catalog data is imported from a JSON file. Also, in App, it refers to the FilterBar component. The FilterBar component is responsible for handling the sorting and filtering dropdowns so that the new data is rendered correctly in the catalog section. And the FilterBar component refers to the CaveItem component. The CaveItem component is essentially responsible for building a single item card for the interface which is why I chose to make it its own individual componentâ€“ so that it could be reused in FilterBar. The CaveItem component returns all the necessary information for a single item as well as the functionality for adding the item to the Favorites list.

### How Data is Passed Down Through Components
As aforementioned, in App, all the catalog data is imported from the app-data.JSON file. Using a props parameter, when I refer to FilterBar in App, I pass in the data to FilterBar with a prop named caveCatalog. Another time where I pass down data to another component, is when I reference CaveItem in FilterBar. CaveItem needs to know the item information (like album name, artist, decade, genre, etc.); CaveItem also needs to have the ability to alter the state of the Favorites list. Therefore, I pass in the item information as props (ex:  itemName, itemImg, itemDesc, itemGenre, and itemDecade). I also pass in the setCartItems and setCartTotal functions as a prop so that the state can be altered. Overall, I utilized props and the ability for functions to also be passed in as props to pass down data to various components. The props allowed me to make my interface more dynamic while still splitting reusable code into components.

### How the User Triggers State Changes
The user triggers state changes when performing the following actions: adding/removing from Favorites, changing any of the filter fields, and modifying the sort type. By adding/removing from Favorites, the user triggers a change in the state of cartItems and inCart which allows the interface to keep track of which items have been favorited. Additionally, when the user selects a new option on the genre or decade dropdown, then the genre and decade states are updated so that the catalog is re-rendered to show only the relevant items. Likewise, when the user selects a new option to sort by, then the sortType state is changed to the corresponding selection. And whenever new data is rendered, the data state is updated so that the correct data is mapped and displayed in the catalog section.
